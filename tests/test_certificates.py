# Test all certificate combinations (rsa-rsa, rsa-dsa, dsa-rsa, etc.)
# Random values for fields, push specifications
# All exceptions
# to/from file and string
# Generated by ssh-keygen and decoded by script, created by script and verified by ssh-keygen

import unittest
import random
import datetime
import faker

import src.sshkey_tools.keys as _KEY
import src.sshkey_tools.fields as _FIELD
import src.sshkey_tools.cert as _CERT
import src.sshkey_tools.exceptions as _EX

types = ['RSA', 'DSA', 'ECDSA', 'ED25519']

class TestCertificateFields(unittest.TestCase):
    def setUp(self):
        self.faker = faker.Faker()
    
    def assertRandomResponse(self, field_class, values = None, random_function = None):
        if values is None:
            values = [random_function() for _ in range(100)]

        fields = []
        
        bytestring = b''
        for value in values:
            bytestring += field_class.encode(value)
            
            field = field_class(value)
            self.assertTrue(field.validate())
            fields.append(field)
            
        self.assertEqual(
            bytestring,
            b''.join(bytes(x) for x in fields)
        )
        
        decoded = []
        while bytestring != b'':
            decode, bytestring = field_class.decode(bytestring)
            decoded.append(decode)
            
        self.assertEqual(
            decoded,
            values
        )
    
    def assertExpectedResponse(self, field_class, input, expected_output):
        self.assertEqual(
            field_class.encode(input),
            expected_output
        )
    
    def test_boolean_field(self):
        self.assertRandomResponse(
            _FIELD.BooleanField,
            random_function=lambda : bool(random.randint(0, 1)) 
        )
        
    def test_invalid_boolean_field(self):
        field = _FIELD.BooleanField("SomeInvalidData")
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
            
    def test_string_field_strings(self):
        strings = []
        fields = []
        for _ in range(100):
            randstring = ''.join(
                random.choice('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789') 
                for _ in range(random.randint(1, 100)
                )
            )
            strings.append(randstring)
            
            field = _FIELD.StringField(randstring)
            self.assertTrue(field.validate())
            fields.append(field)
            
        bytestring = b''
        for string in strings:
            bytestring += _FIELD.StringField.encode(string, 'utf-8')
            
        self.assertIsInstance(
            bytestring,
            bytes
        )
        self.assertIsInstance(
            b''.join(bytes(x) for x in fields),
            bytes
        )
            
        self.assertEqual(
            bytestring,
            b''.join(bytes(x) for x in fields)
        )
        
        decoded = []
        while bytestring != b'':
            decode, bytestring = _FIELD.StringField.decode(bytestring)
            decoded.append(decode.decode('utf-8'))
            
        self.assertEqual(
            strings,
            decoded
        )

    def test_invalid_string_field(self):
        field = _FIELD.StringField(ValueError)
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
    def test_integer32_field(self):
        self.assertRandomResponse(
            _FIELD.Integer32Field,
            random_function=lambda : random.randint(2**2, 2**32)
        )
        
    def test_invalid_integer32_field(self):
        field = _FIELD.Integer32Field(ValueError)
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
        field = _FIELD.Integer32Field(_FIELD.MAX_INT32 + 1)
        
        self.assertIsInstance(
            field.validate(),
            _EX.IntegerOverflowException
        )
        
    def test_integer64_field(self):
        self.assertRandomResponse(
            _FIELD.Integer64Field,
            random_function=lambda : random.randint(2**32, 2**64)
        )
        
    def test_invalid_integer64_field(self):
        field = _FIELD.Integer32Field(ValueError)
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
        field = _FIELD.Integer32Field(_FIELD.MAX_INT32 + 1)
        
        self.assertIsInstance(
            field.validate(),
            _EX.IntegerOverflowException
        )
        
    
        
    def test_datetime_field(self):
        self.assertRandomResponse(
            _FIELD.DateTimeField,
            random_function=lambda : self.faker.date_time()
        )
        
    def test_invalid_datetime_field(self):
        field = _FIELD.DateTimeField(ValueError)
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
    def test_mp_integer_field(self):
        self.assertRandomResponse(
            _FIELD.MpIntegerField,
            random_function=lambda : random.randint(2**128, 2**512)
        )
        
    def test_invalid_mp_integer_field(self):
        field = _FIELD.MpIntegerField(ValueError)
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
        field = _FIELD.MpIntegerField('InvalidData')
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
    def test_standard_list_field(self):
        