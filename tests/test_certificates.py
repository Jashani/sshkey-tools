# Test all certificate combinations (rsa-rsa, rsa-dsa, dsa-rsa, etc.)
# Random values for fields, push specifications
# All exceptions
# to/from file and string
# Generated by ssh-keygen and decoded by script, created by script and verified by ssh-keygen

import os
import unittest
import random
import datetime
import faker

import src.sshkey_tools.keys as _KEY
import src.sshkey_tools.fields as _FIELD
import src.sshkey_tools.cert as _CERT
import src.sshkey_tools.exceptions as _EX

types = ['RSA', 'DSA', 'ECDSA', 'ED25519']

class TestCertificateFields(unittest.TestCase):
    def setUp(self):
        self.faker = faker.Faker()
        self.rsa_key = _KEY.RSAPrivateKey.generate(1024)
        self.dsa_key = _KEY.DSAPrivateKey.generate()
        self.ecdsa_key = _KEY.ECDSAPrivateKey.generate()
        self.ed25519_key = _KEY.ED25519PrivateKey.generate()
    
    def assertRandomResponse(self, field_class, values = None, random_function = None):
        if values is None:
            values = [random_function() for _ in range(100)]

        fields = []
        
        bytestring = b''
        for value in values:
            bytestring += field_class.encode(value)
            
            field = field_class(value)
            self.assertTrue(field.validate())
            fields.append(field)
            
        self.assertEqual(
            bytestring,
            b''.join(bytes(x) for x in fields)
        )
        
        decoded = []
        while bytestring != b'':
            decode, bytestring = field_class.decode(bytestring)
            decoded.append(decode)
            
        self.assertEqual(
            decoded,
            values
        )
    
    def assertExpectedResponse(self, field_class, input, expected_output):
        self.assertEqual(
            field_class.encode(input),
            expected_output
        )
    
    def test_boolean_field(self):
        self.assertRandomResponse(
            _FIELD.BooleanField,
            random_function=lambda : self.faker.pybool() 
        )
        
    def test_invalid_boolean_field(self):
        field = _FIELD.BooleanField("SomeInvalidData")
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
        with self.assertRaises(_EX.InvalidFieldDataException):
            field.encode(ValueError)
            
    def test_string_field_strings(self):
        strings = []
        fields = []
        for _ in range(100):
            randstring = ''.join(
                random.choice('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789') 
                for _ in range(random.randint(1, 100)
                )
            )
            strings.append(randstring)
            
            field = _FIELD.StringField(randstring)
            self.assertTrue(field.validate())
            fields.append(field)
            
        bytestring = b''
        for string in strings:
            bytestring += _FIELD.StringField.encode(string, 'utf-8')
            
        self.assertIsInstance(
            bytestring,
            bytes
        )
        self.assertIsInstance(
            b''.join(bytes(x) for x in fields),
            bytes
        )
            
        self.assertEqual(
            bytestring,
            b''.join(bytes(x) for x in fields)
        )
        
        decoded = []
        while bytestring != b'':
            decode, bytestring = _FIELD.StringField.decode(bytestring)
            decoded.append(decode.decode('utf-8'))
            
        self.assertEqual(
            strings,
            decoded
        )

    def test_invalid_string_field(self):
        field = _FIELD.StringField(ValueError)
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
        with self.assertRaises(_EX.InvalidFieldDataException):
            field.encode(ValueError)
        
    def test_integer32_field(self):
        self.assertRandomResponse(
            _FIELD.Integer32Field,
            random_function=lambda : random.randint(2**2, 2**32)
        )
        
    def test_invalid_integer32_field(self):
        field = _FIELD.Integer32Field(ValueError)
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
        field = _FIELD.Integer32Field(_FIELD.MAX_INT32 + 1)
        
        self.assertIsInstance(
            field.validate(),
            _EX.IntegerOverflowException
        )
        
        with self.assertRaises(_EX.InvalidFieldDataException):
            field.encode(ValueError)
        
    def test_integer64_field(self):
        self.assertRandomResponse(
            _FIELD.Integer64Field,
            random_function=lambda : random.randint(2**32, 2**64)
        )
        
    def test_invalid_integer64_field(self):
        field = _FIELD.Integer64Field(ValueError)
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
        field = _FIELD.Integer64Field(_FIELD.MAX_INT64 + 1)
        
        self.assertIsInstance(
            field.validate(),
            _EX.IntegerOverflowException
        )
        
        with self.assertRaises(_EX.InvalidFieldDataException):
            field.encode(ValueError)
        
    def test_datetime_field(self):
        self.assertRandomResponse(
            _FIELD.DateTimeField,
            random_function=lambda : self.faker.date_time()
        )
        
    def test_invalid_datetime_field(self):
        field = _FIELD.DateTimeField(ValueError)
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
        with self.assertRaises(_EX.InvalidFieldDataException):
            field.encode(ValueError)
        
    def test_mp_integer_field(self):
        self.assertRandomResponse(
            _FIELD.MpIntegerField,
            random_function=lambda : random.randint(2**128, 2**512)
        )
        
    def test_invalid_mp_integer_field(self):
        field = _FIELD.MpIntegerField(ValueError)
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
        field = _FIELD.MpIntegerField('InvalidData')
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
        with self.assertRaises(_EX.InvalidFieldDataException):
            field.encode(ValueError)
        
    def test_standard_list_field(self):
        self.assertRandomResponse(
            _FIELD.StandardListField,
            random_function=lambda : [bytes(self.faker.pystr(0, 100), 'utf-8') for _ in range(10)]
        )
        
    def test_invalid_standard_list_field(self):
        field = _FIELD.StandardListField(ValueError)
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )

        field = _FIELD.StandardListField([ValueError, ValueError, ValueError])
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
        with self.assertRaises(_EX.InvalidFieldDataException):
            field.encode(ValueError)
        
    def test_separated_list_field(self):
        self.assertRandomResponse(
            _FIELD.SeparatedListField,
            random_function=lambda : [bytes(self.faker.pystr(1, 100), 'utf-8') for _ in range(10)]
        )
        
    def test_invalid_separated_list_field(self):
        field = _FIELD.SeparatedListField(ValueError)
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )

        field = _FIELD.SeparatedListField([ValueError, ValueError, ValueError])
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
        with self.assertRaises(_EX.InvalidFieldDataException):
            field.encode(ValueError)
            
    def test_pubkey_type_field(self):
        allowed_values = (
            ('ssh-rsa-cert-v01@openssh.com', b'\x00\x00\x00\x1cssh-rsa-cert-v01@openssh.com'),
            ('rsa-sha2-256-cert-v01@openssh.com', b'\x00\x00\x00!rsa-sha2-256-cert-v01@openssh.com'),
            ('rsa-sha2-512-cert-v01@openssh.com', b'\x00\x00\x00!rsa-sha2-512-cert-v01@openssh.com'),
            ('ssh-dss-cert-v01@openssh.com', b'\x00\x00\x00\x1cssh-dss-cert-v01@openssh.com'),
            ('ecdsa-sha2-nistp256-cert-v01@openssh.com', b'\x00\x00\x00(ecdsa-sha2-nistp256-cert-v01@openssh.com'),
            ('ecdsa-sha2-nistp384-cert-v01@openssh.com', b'\x00\x00\x00(ecdsa-sha2-nistp384-cert-v01@openssh.com'),
            ('ecdsa-sha2-nistp521-cert-v01@openssh.com', b'\x00\x00\x00(ecdsa-sha2-nistp521-cert-v01@openssh.com'),
            ('ssh-ed25519-cert-v01@openssh.com', b'\x00\x00\x00 ssh-ed25519-cert-v01@openssh.com')
        )
        
        for value in allowed_values:
            self.assertExpectedResponse(
                _FIELD.PubkeyTypeField,
                value[0],
                value[1]
            )
        
    def test_invalid_pubkey_type_field(self):
        field = _FIELD.PubkeyTypeField('HelloWorld')
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidDataException
        )
        
        with self.assertRaises(_EX.InvalidFieldDataException):
            field.encode(ValueError)
        
    def test_nonce_field(self):
        randomized = _FIELD.NonceField()
        
        self.assertTrue(randomized.validate())
        
        specific = (
            'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz', 
            b'\x00\x00\x004abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz'
        )
        
        self.assertExpectedResponse(
            _FIELD.NonceField,
            specific[0],
            specific[1]
        )
        
    def test_pubkey_class_assignment(self):
        rsa_field = _FIELD.PublicKeyField.from_object(self.rsa_key.public_key)
        dsa_field = _FIELD.PublicKeyField.from_object(self.dsa_key.public_key)
        ecdsa_field = _FIELD.PublicKeyField.from_object(self.ecdsa_key.public_key)
        ed25519_field = _FIELD.PublicKeyField.from_object(self.ed25519_key.public_key)
        
        self.assertIsInstance(rsa_field, _FIELD.RSAPubkeyField)
        self.assertIsInstance(dsa_field, _FIELD.DSAPubkeyField)
        self.assertIsInstance(ecdsa_field, _FIELD.ECDSAPubkeyField)
        self.assertIsInstance(ed25519_field, _FIELD.ED25519PubkeyField)
        
        self.assertTrue(rsa_field.validate())
        self.assertTrue(dsa_field.validate())
        self.assertTrue(ecdsa_field.validate())
        self.assertTrue(ed25519_field.validate())
     
    def assertPubkeyOutput(self, key_class, *opts):
        key = getattr(self, key_class.__name__.replace('PrivateKey', '').lower() + '_key').public_key
        raw_start = key.raw_bytes()
        field = _FIELD.PublicKeyField.from_object(key)
        byte_data = bytes(field)
        decoded = field.decode(byte_data)[0]
        
        self.assertTrue(field.validate())
        
        self.assertEqual(
            raw_start,
            decoded.raw_bytes()
        )
        
        self.assertEqual(
            f'{key.__class__.__name__.replace("PublicKey", "")} {key.get_fingerprint()}',
            str(field)
        )
        
        
    def test_rsa_pubkey_output(self):
        self.assertPubkeyOutput(
            _KEY.RSAPrivateKey,
            1024
        )
        
    def test_dsa_pubkey_output(self):
        self.assertPubkeyOutput(
            _KEY.DSAPrivateKey
        )
        
    def test_ecdsa_pubkey_output(self):
        self.assertPubkeyOutput(
            _KEY.ECDSAPrivateKey
        )
        
    def test_ed25519_pubkey_output(self):
        self.assertPubkeyOutput(
            _KEY.ED25519PrivateKey
        )
        
    def test_serial_field(self):
        self.assertRandomResponse(
            _FIELD.SerialField,
            random_function=lambda : random.randint(0, 2**64 - 1)
        )
        
    def test_invalid_serial_field(self):
        field = _FIELD.SerialField('abcdefg')
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
        field = _FIELD.SerialField(random.randint(2**65, 2**66))
        
        self.assertIsInstance(
            field.validate(),
            _EX.IntegerOverflowException
        )
        
        with self.assertRaises(_EX.InvalidFieldDataException):
            field.encode(ValueError)
        
    def test_certificate_type_field(self):
        self.assertExpectedResponse(
            _FIELD.CertificateTypeField,
            1,
            b'\x00\x00\x00\x01'
        )
        
        self.assertExpectedResponse(
            _FIELD.CertificateTypeField,
            2,
            b'\x00\x00\x00\x02'
        )
        
        self.assertExpectedResponse(
            _FIELD.CertificateTypeField,
            _FIELD.CERT_TYPE.USER,
            b'\x00\x00\x00\x01'
        )
        
        self.assertExpectedResponse(
            _FIELD.CertificateTypeField,
            _FIELD.CERT_TYPE.HOST,
            b'\x00\x00\x00\x02'
        )
        
    def test_invalid_certificate_field(self):
        field = _FIELD.CertificateTypeField(ValueError)
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
        field = _FIELD.CertificateTypeField(3)
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidDataException
        )
        
        field = _FIELD.CertificateTypeField(0)
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidDataException
        )
        
        with self.assertRaises(_EX.InvalidFieldDataException):
            field.encode(ValueError)
        
    def test_key_id_field(self):
        self.assertRandomResponse(
            _FIELD.KeyIDField,
            random_function=lambda : self.faker.pystr(8, 128).encode('utf-8')
        )
        
    def test_invalid_key_id_field(self):
        field = _FIELD.KeyIDField('')
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidDataException
        )
        
        with self.assertRaises(_EX.InvalidFieldDataException):
            field.encode(ValueError)
        
    def test_principals_field(self):
        self.assertRandomResponse(
            _FIELD.PrincipalsField,
            random_function=lambda : [self.faker.pystr(8, 128).encode('utf-8') for _ in range(20)]
        )
    
        comparison = [self.faker.pystr(8, 128).encode('utf-8') for _ in range(20)]
    
        self.assertExpectedResponse(
            _FIELD.PrincipalsField,
            comparison,
            _FIELD.StandardListField.encode(comparison)
        )
        
    def test_invalid_principals_field(self):
        field = _FIELD.PrincipalsField([ValueError, ValueError, ValueError])
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
        with self.assertRaises(_EX.InvalidFieldDataException):
            field.encode(ValueError)
        
    def test_validity_start_field(self):
        self.assertRandomResponse(
            _FIELD.ValidityStartField,
            random_function=lambda : self.faker.date_time()
        )
        
    def test_invalid_validity_start_field(self):
        field = _FIELD.ValidityStartField(ValueError)
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
        with self.assertRaises(_EX.InvalidFieldDataException):
            field.encode(ValueError)
        
    def test_validity_end_field(self):
        self.assertRandomResponse(
            _FIELD.ValidityEndField,
            random_function=lambda : self.faker.date_time()
        )
        
    def test_invalid_validity_end_field(self):
        field = _FIELD.ValidityEndField(ValueError)
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
        with self.assertRaises(_EX.InvalidFieldDataException):
            field.encode(ValueError)
        
    def test_critical_options_field(self):
        valid_values = [
            b'force-command=sftp',
            b'source_address=1.2.3.4',
            b'verify_required=true',
            b'no-touch-required',
            b'permit-X11-forwarding',
            b'permit-agent-forwarding',
            b'permit-port-forwarding',
            b'permit-pty',
            b'permit-user-rc'
        ]
        
        self.assertRandomResponse(
            _FIELD.CriticalOptionsField,
            values=[valid_values[0:random.randint(1,len(valid_values))] for _ in range(10)]
        )
        
    def test_invalid_critical_options_field(self):
        field = _FIELD.CriticalOptionsField([ValueError, 'permit-pty', 'unpermit'])
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
        field = _FIELD.CriticalOptionsField('InvalidData')
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
        field = _FIELD.CriticalOptionsField(['no-touch-required', 'InvalidOption'])
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
        with self.assertRaises(_EX.InvalidFieldDataException):
            field.encode(ValueError)
        
    def test_extensions_field(self):
        valid_values = [
            b'no-touch-required',
            b'permit-X11-forwarding',
            b'permit-agent-forwarding',
            b'permit-port-forwarding',
            b'permit-pty',
            b'permit-user-rc'
        ]
        
        self.assertRandomResponse(
            _FIELD.ExtensionsField,
            values=[valid_values[0:random.randint(1,len(valid_values))] for _ in range(10)]
        )
        
    def test_invalid_extensions_field(self):
        field = _FIELD.CriticalOptionsField([ValueError, 'permit-pty', b'unpermit'])
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
        field = _FIELD.CriticalOptionsField('InvalidData')
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
        field = _FIELD.CriticalOptionsField(['no-touch-required', 'InvalidOption'])
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidFieldDataException
        )
        
        with self.assertRaises(_EX.InvalidFieldDataException):
            field.encode(ValueError)
    
    def test_reserved_field(self):
        self.assertExpectedResponse(
            _FIELD.ReservedField,
            '',
            b'\x00\x00\x00\x00'
        )

    def test_invalid_reserved_field(self):
        field = _FIELD.ReservedField('InvalidData')
        
        self.assertIsInstance(
            field.validate(),
            _EX.InvalidDataException
        )
        
        with self.assertRaises(_EX.InvalidFieldDataException):
            field.encode(ValueError)
    
    def assertCAPubkeyField(self, type):
        key = getattr(self, f'{type}_key').public_key
        field = _FIELD.CAPublicKeyField.from_object(key)
        encoded = bytes(field)
        decoded = field.decode(encoded)[0]
        
        self.assertEqual(
            key.raw_bytes(),
            decoded.raw_bytes()
        )
        
        self.assertEqual(
            f'{type.upper()} {key.get_fingerprint()}',
            str(field)
        )
        
class TestCertificates(unittest.TestCase):
    def setUp(self):
        self.faker = faker.Faker()
        self.cert_opts = {
            'serial': 1234567890,
            'cert_type': _FIELD.CERT_TYPE.USER.value,
            'key_id': 'KeyIdentifier',
            'principals': [
                'pr_a',
                'pr_b',
                'pr_c'
            ],
            'valid_after': 1968491468.590164,
            'valid_before': 1968534668.590224,
            'critical_options': [
                'force-command=sftp',
                'source_address=1.2.3.4/8',
                'permit-X11-forwarding'
            ],
            'extensions': [
                'permit-agent-forwarding',
                'permit-X11-forwarding'
            ]
        }
        
    def test_create_rsa_cert(self):
        user_pub = _KEY.RSAPrivateKey.generate(1024).public_key
        ca_priv = _KEY.RSAPrivateKey.generate(1024)
        
        cert = _CERT.SSHCertificate(
            user_pub,
            ca_priv,
            **self.cert_opts
        )
        
        self.assertTrue(cert.can_sign())
        cert.sign()
        
        cert.to_file('test_certificate')
        os.system('ssh-keygen -Lf test_certificate')
        
if __name__ == '__main__':
    unittest.main()